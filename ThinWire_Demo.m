%  This code demonstrates the use of thin wires to approximate a current
% density. In gradient coil design for MRI usually only the the z-component
% of the magnetic field (Bz) is considered. Hence, only wires orthogonal to
% z are used in this simulation. A sensitivity matrix is used to calculate
% acurrent distribution. A regularization and an additional constraint is
% deployed to derive a ralizable coil design.
% This method may be used for simple geometries. However, no generalization
% for arbitrary surfaces.
%
% 2019-11
% Sebastian Littin
% sebastian.littin@uniklinik-freiburg.de

clear all
close all


%% coil description: Cylindrical unshielded coil

% define coil-parameters of a current matrix with wire elements orthogonal to z

CoilDefinition.Partitions = 1;
segments_angular=56;
half_length=0.6; % 600mm
len_step = 0.02; % 20mm
r_coil = 0.4;  % 800mm coil diameter

arc_angle = 360/(segments_angular);
[elm_angle, elm_z] = ndgrid((0:segments_angular-1)*arc_angle, (-half_length:len_step:half_length));
CoilDefinition(1).num_elements=size(elm_angle);
elm_angle_shift = elm_angle([2:end,1],:);

% Define Cylindrical Main Surface
CoilDefinition(1).thin_wire_nodes_start = [cosd(elm_angle(:))*r_coil,sind(elm_angle(:))*r_coil,elm_z(:)];
CoilDefinition(1).thin_wire_nodes_stop = [cosd(elm_angle_shift(:))*r_coil,sind(elm_angle_shift(:))*r_coil,elm_z(:)];

CoilDefinition(1).num_elements = size(elm_angle);


%% Definition of target points in a 3D-volume

TargetDefinition.shape = 'sphere';
TargetDefinition.radius = 0.2;
TargetDefinition.resol_radial = 3;
TargetDefinition.resol_angular = 15;
TargetDefinition.strength = 5e-3;
TargetDefinition.direction = 'y';

target_points = Make_Target(TargetDefinition);

% plot target
figure; scatter3(target_points.points.x1(:), target_points.points.x2(:), target_points.points.x3(:), ones(size(target_points.points.x1(:)))*25, target_points.field(:))
axis equal tight
title('Target Points and Field');
view([1 1 1])

x1 = target_points.points.x1(:);
x2 = target_points.points.x2(:);
x3 = target_points.points.x3(:);

Points=[x1(:),x2(:),x3(:)];
Target.Points=Points;
num_points=length(Points(:,1));
Target.num_points = num_points;

kn = length(x1)^2;
kp = length(x1);

%% plot the thin wire elements

figure;
hold all
for n = 1:length(CoilDefinition(1).thin_wire_nodes_start)
    plot3([CoilDefinition(1).thin_wire_nodes_start(n,1) CoilDefinition(1).thin_wire_nodes_stop(n,1)], ...
        [CoilDefinition(1).thin_wire_nodes_start(n,2) CoilDefinition(1).thin_wire_nodes_stop(n,2)],...
        [CoilDefinition(1).thin_wire_nodes_start(n,3) CoilDefinition(1).thin_wire_nodes_stop(n,3)])
    
end
hold off
axis equal tight
title('Thin-wire current elements');
view([1 1 1])

% Some definitions for 3D contour plotting...
CoilDefinition(1).Radius = r_coil;
CoilDefinition(1).Length = half_length*2;


%% Calculate a sensitivity matrix which describes the field generated by each thin-wire at each target point

CoilDefinition(1).StreamDirection = 2;

Sensitivity = ThinWireSensitivity(CoilDefinition, Target);


%% Calculate a unregularized solution using Moore-Penrose pseudoinverse (pinv)

btarget = target_points.field;
ElementCurrents = pinv(Sensitivity.ElementFields)*btarget;
ResultingField = Sensitivity.ElementFields*ElementCurrents;


figure; set(gcf,'Name','Unregularized Currents','Position',[   1   1   500   500]);
imab(reshape(ElementCurrents,size(elm_angle)));
 title('Unregularized current distribution');
 ylabel('z-Axis [m]')
 xlabel('circumferential [rad]')


%% Calculate simple Tikhonov-regularized solution
% Unfortunately this results in a crrent distribution which is not
% realizable with closed loops...

ElementCurrents=TikhonovReg(Sensitivity.ElementFields, btarget, 0.0077); % regularisation automatically penelizes total power
figure; set(gcf,'Name','Tikhonov regularized','Position',[   1   1   500   500]);
imab(reshape(ElementCurrents,size(elm_angle)));
 title('Regularized current distribution');
 ylabel('z-Axis [m]')
 xlabel('circumferential [rad]')

%% Plot the stream function and stream lines in 2D...

ElementCurrents_Balance_reshape = reshape(ElementCurrents,size(elm_angle));

Stream_Reg=cumsum(ElementCurrents_Balance_reshape(:,end:-1:1),2);
Stream_Reg_rev=cumsum(ElementCurrents_Balance_reshape,2);

Stream = zeros(size(Stream_Reg)+[0 1]);
Stream(:,2:end) = Stream_Reg./2;
Stream(:,1:end-1) = Stream(:,1:end-1)-Stream_Reg_rev(:,end:-1:1)./2;

figure; set(gcf,'Name','Regularized Stream Function','Position',[   1   1   500   500]);
hold all
imab(Stream);
cont_max = max(max(Stream))*0.98;
n_cont = 15;
[C,H] = contour(Stream(:,:)',[-cont_max:(2*cont_max/n_cont):cont_max],'k','LineWidth', 2);
hold off
 title('Stream function from integrating the currents');
 ylabel('z-Axis [m]')
 xlabel('circumferential [rad]')

%% Add additional constraints to the regularisation
% add conditions for balancing along each angular column
% => This ensures that the sum of currents along z=0 -> realizable as
% closed loops. As many equations as angular segments are needed

eye_ang=eye(size(elm_angle,1));
ElementFields_Add3D=eye_ang(:,:,ones(1,size(elm_angle,2)));
ElementFields_Add=ElementFields_Add3D(:,:);
TargetFields_Add=zeros(size(elm_angle,1),1);

ElementFields_Balance = [Sensitivity.ElementFields; ElementFields_Add*5e-4]; % this coefficient controls the relative importance of the new equations
TargetField_Balance = [btarget; TargetFields_Add];

% Do regularization
ElementCurrents_Balance = TikhonovReg(ElementFields_Balance, TargetField_Balance, 0.00005); % this time regularization is very different and depends on the above coefficient

% Calculate resulting field
ResultingField_Balance = Sensitivity.ElementFields*ElementCurrents_Balance;

figure; set(gcf,'Name','Regularized currents with constraints','Position',[   1   1   500   500]);
TargetField_Balance = [btarget; TargetFields_Add];
imab(reshape(ElementCurrents_Balance,size(elm_angle)));
 title('Regularized currents with balance');
 ylabel('z-Axis [m]')
 xlabel('circumferential [rad]')

ElementCurrents_Balance_reshape = reshape(ElementCurrents_Balance,size(elm_angle));
%%
% Calculate the Stream function from the current distribution, using the
% cumulative sum (=integral) along z. To balance unsymmetric solutions and 
% prevent from shifts along z an interation is performed from both sides
% and added.

Stream_Reg=cumsum(ElementCurrents_Balance_reshape(:,end:-1:1),2);
Stream_Reg_rev=cumsum(ElementCurrents_Balance_reshape,2);

Stream = zeros(size(Stream_Reg)+[0 1]);
Stream(:,2:end) = Stream_Reg./2;
Stream(:,1:end-1) = Stream(:,1:end-1)-Stream_Reg_rev(:,end:-1:1)./2;

% Stream = -Stream_Reg_rev;

%% Plot the stream function and stream lines in 2D...

figure; set(gcf,'Name','Regularized Stream Function','Position',[   1   1   500   500]);

hold all
imab(Stream);
cont_max = max(max(Stream))*0.98;%4500;
n_cont = 15;
[C,H] = contour(Stream(:,:)',[-cont_max:(2*cont_max/n_cont):cont_max],'k','LineWidth', 2);
hold off
 title('Stream function from integrating the currents');
 ylabel('z-Axis [m]')
 xlabel('circumferential [rad]')


%% 3D Plot of the stream function


PlotCoord = (CoilDefinition.thin_wire_nodes_start);
sx = reshape(PlotCoord(:,1),CoilDefinition.num_elements);
sy = reshape(PlotCoord(:,2),CoilDefinition.num_elements);
sz = reshape(PlotCoord(:,3),CoilDefinition.num_elements);

% fix the size of the spatial locations due to size changes from the manual integration
sx_p = [sx sx(:,1)];
sy_p = [sy sy(:,1)];

sz_p = zeros(size(Stream));
sz_p(:,2:end) = sz./2;
sz_p(:,1:end-1) = sz./2+sz_p(:,1:end-1);
sz_p(:,1) = sz_p(:,1)*2;
sz_p(:,end) = sz_p(:,end)*2;
 
% tiny Hack to plot all radial elements, because surf does not plot all
% elements...
sx_ph = [sx_p; sx_p(1,:)];
sy_ph = [sy_p; sy_p(1,:)];
sz_ph = [sz_p; sz_p(1,:)];
Stream_p = [Stream; Stream(1,:)];

figure; set(gcf,'Name','3D Stream function','Position',[   1   1   500   500]);
hold all
surf(sx_ph,sy_ph,sz_ph,Stream_p,'EdgeColor','none');
hold off
xlabel('x-Axis [m]');
ylabel('y-Axis [m]');
zlabel('z-Axis [m]');
view([-7 25]);

axis tight equal
font_size = 12;
set(gca,'fontsize',font_size)
title('Stream function in 3D representation');


%%

n_cont = 13;

cont_max_main = max(max(Stream))-500;
[C1,H1] = contour(Stream(:,:)',[-cont_max_main:(2*cont_max_main/n_cont):cont_max_main],'k','LineWidth', 2);

%% 3D Plot of the contours

figure; set(gcf,'Name','3D contours','Position',[   1   1   500   500]);
hold all

S = contourdata(C1);
ccount = size(S);
nP =1;
for i = 1:ccount(2)
    sxp=r_coil*cos(S(i).xdata/(CoilDefinition(nP).num_elements(1))*2*pi);
    syp=r_coil.*sin(S(i).xdata/(CoilDefinition(nP).num_elements(1))*2*pi);
    szp=S(i).ydata./length(Stream(1,:)')*CoilDefinition(nP).Length - CoilDefinition(nP).Length/2;
    
    plot3(sxp,syp,szp,'b','LineWidth', 1)
end

hold off
view([-7 25]);

axis tight equal
font_size = 12;
set(gca,'fontsize',font_size)



%% 3D Plot of the contours and stream function


figure; set(gcf,'Name','3D coil','Position',[   1   1   500   500]);
hold all

S = contourdata(C1);
ccount = size(S);
nP =1;
for i = 1:ccount(2)
    sxp=r_coil*cos(S(i).xdata/(CoilDefinition(nP).num_elements(1))*2*pi);
    syp=r_coil.*sin(S(i).xdata/(CoilDefinition(nP).num_elements(1))*2*pi);
    szp=S(i).ydata./length(Stream(1,:)')*CoilDefinition(nP).Length - CoilDefinition(nP).Length/2;
    
    plot3(sxp,syp,szp,'k','LineWidth', 2)
end
surf(sx_ph,sy_ph,sz_ph,Stream_p,'EdgeColor','none');
hold off
view([-7 25]);

axis tight equal off
font_size = 12;
set(gca,'fontsize',font_size)

